#version 450

#include "mesh_adv_types.glsl"

// @[export]
struct BoundingSphere {
    vec3 position;
    float radius;
};

// @[export]
struct IndirectCommand {
    uint index_count;
    uint instance_count;
    uint first_index;
    int vertex_offset;
    uint first_instance;
};

// Data for the view we are processing
// @[export]
// @[internal_buffer]
layout (set = 0, binding = 0) uniform Config {
    mat4 view_matrix;
    mat4 proj_matrix;
    uint draw_data_count;
    uint indirect_first_command_index;
    uint depth_mip_slice_count;
    uint viewport_width;
    uint viewport_height;
    float z_near;
    bool write_debug_output;
} config;

// The draw_data - we use this to pair transform/bounding data with a slot in the indirect command buffer
layout (set = 0, binding = 1) buffer AllDrawData {
    DrawData draw_data[];
} all_draw_data;

// Bounding sphere of each object, indexed by transform_index (this is a parallel array with transforms)
layout (set = 0, binding = 2) buffer AllBoundingSpheres {
    BoundingSphere bounding_spheres[];
} all_bounding_spheres;

// The output data - we will poke a 0 or 1 into the instance_count field depending on if it's visible
layout (set = 0, binding = 3) buffer IndirectData {
    IndirectCommand indirect_commands[];
} all_indirect_commands;

// @[export]
layout (set = 0, binding = 4) uniform texture2D depth_mip_slices[16];

// @[immutable_samplers([
//     (
//         mag_filter: Nearest,
//         min_filter: Nearest,
//         mip_map_mode: Linear,
//         address_mode_u: ClampToEdge,
//         address_mode_v: ClampToEdge,
//         address_mode_w: ClampToEdge,
//     )
// ])]
layout (set = 0, binding = 5) uniform sampler smp;

//
// Currently don't need this, we pre-transform the bounding spheres
//
// Transform of the each object, indexed by transform_index
/*
layout (set = 0, binding = 6) buffer AllTransforms {
    Transform transforms[];
} all_transforms;
*/

// @[export]
struct PerCullInfo {
    bool was_culled;
};

// @[export]
layout (set = 0, binding = 6) buffer DebugOutput {
    uint total_mesh_count;
    uint culled_mesh_count;
    uint total_primitive_count;
    uint culled_primitive_count;
    PerCullInfo per_cull_info[4000];
} debug_output;

layout(local_size_x = 1, local_size_y = 64, local_size_z = 1) in;
void main() {
    //
    // Bail if this thread is not in-bounds of the draw data list
    //
    uint draw_index = gl_GlobalInvocationID.y;
    if (draw_index >= config.draw_data_count) {
        return;
    }

    //
    // Debug output
    //
    if (config.write_debug_output) {
        uint indirect_index = config.indirect_first_command_index + draw_index;
        atomicAdd(debug_output.total_mesh_count, 1);
        atomicAdd(debug_output.total_primitive_count, all_indirect_commands.indirect_commands[indirect_index].index_count / 3);
    }

    //
    // Determine location of bounding sphere in view space
    // TODO: We currently pre-transform position/radius on CPU
    //
    uint transform_index = all_draw_data.draw_data[draw_index].transform_index;
    BoundingSphere bs = all_bounding_spheres.bounding_spheres[transform_index];
    //Transform transform = all_transforms.transforms[transform_index];
    vec3 center_vs = (config.view_matrix * vec4(bs.position, 1.0)).xyz;
    float radius = bs.radius;

    //
    // If radius is -1, assume it's never culled
    //
    if (radius < 0.0) {
        return;
    }

    //
    // Find an AABB aligned to view space
    // TODO: Optimize by doing log(n) min/max calls?
    //
    vec3 min_bounds_vs = center_vs;
    vec3 max_bounds_vs = center_vs;
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3(-radius, -radius, -radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3(-radius, -radius,  radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3(-radius,  radius, -radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3(-radius,  radius,  radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3( radius, -radius, -radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3( radius, -radius,  radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3( radius,  radius, -radius));
    min_bounds_vs = min(min_bounds_vs, center_vs + vec3( radius,  radius,  radius));

    max_bounds_vs = max(max_bounds_vs, center_vs + vec3(-radius, -radius, -radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3(-radius, -radius,  radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3(-radius,  radius, -radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3(-radius,  radius,  radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3( radius, -radius, -radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3( radius, -radius,  radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3( radius,  radius, -radius));
    max_bounds_vs = max(max_bounds_vs, center_vs + vec3( radius,  radius,  radius));

    //
    // Project to NDC with perspective divide
    //
    vec4 min_clip = config.proj_matrix * vec4(min_bounds_vs, 1.0);
    vec4 max_clip = config.proj_matrix * vec4(max_bounds_vs, 1.0);

    vec3 ndc1 = min_clip.xyz / min_clip.w;
    vec3 ndc2 = max_clip.xyz / max_clip.w;

    //
    // Re-determine min/max values
    //
    // Projection can flip things around so that min/max is no longer min/max
    vec3 min_ndc = min(ndc1, ndc2);
    vec3 max_ndc = max(ndc1, ndc2);

    //
    // Convert NDC to UV, including flipping Y
    //
    vec2 min_uv = (min_ndc.xy * 0.5) + 0.5;
    vec2 max_uv = (max_ndc.xy * 0.5) + 0.5;
    float temp = min_uv.y;
    min_uv.y = 1.0 - max_uv.y;
    max_uv.y = 1.0 - temp;

    //
    // A sphere depth that clips into the screen can never be rejected, so bail early
    //
    if (min_ndc.z < 0.0) {
        return;
    }

    //
    // Linear search for the mip level where the UV coordinates cover no more than a 2x2 patch
    //
    min_uv = clamp(min_uv, 0, 1);
    max_uv = clamp(max_uv, 0, 1);

    vec2 mip_slice_size;
    ivec2 min_sample_pixel;
    ivec2 max_sample_pixel;
    uint mip_slice = config.depth_mip_slice_count;
    for (int i = 0; i < config.depth_mip_slice_count; ++i) {
        mip_slice_size = vec2(max(uvec2(1,1), uvec2(config.viewport_width>>i, config.viewport_height>>i)));
        min_sample_pixel = ivec2(min_uv * mip_slice_size);
        max_sample_pixel = ivec2(max_uv * mip_slice_size);
        ivec2 pixel_dim = max_sample_pixel - min_sample_pixel;

        if ((max_sample_pixel.x - min_sample_pixel.x < 2) && (max_sample_pixel.y - min_sample_pixel.y < 2)) {
            mip_slice = i;
            break;
        }
    }

    //
    // Bail if no mip satisfied the 2x2 patch size requirement
    //
    if (mip_slice == config.depth_mip_slice_count) {
        return;
    }

    //
    // Gather the 4 pixels of the patch
    //
    //vec2 mip_slice_size = viewport_size / float(1<<mip_slice);
    vec2 gather_pixel = (vec2(min_sample_pixel) + vec2(max_sample_pixel))/2.0;
    vec2 gather_uv = (gather_pixel + vec2(0.5, 0.5)) / mip_slice_size;
    vec4 gathered = textureGather(sampler2D(depth_mip_slices[mip_slice], smp), gather_uv);

    //
    // Find minimum of all 4 pixels that are covered by the uv coordinates
    //
    bool use_both_samples_for_x = min_sample_pixel.x != max_sample_pixel.x;
    bool use_both_samples_for_y = min_sample_pixel.y != max_sample_pixel.y;

    float hiz_depth = gathered.w;
    if (use_both_samples_for_x) {
        hiz_depth = min(hiz_depth, gathered.z);
    }
    if (use_both_samples_for_y) {
        hiz_depth = min(hiz_depth, gathered.x);
    }
    if (use_both_samples_for_x && use_both_samples_for_y) {
        hiz_depth = min(hiz_depth, gathered.y);
    }

    //
    // Cull if the AABB is behind all the depth buffer samples
    //
    float sphere_depth = max_ndc.z;
    if (sphere_depth < hiz_depth) {
        uint indirect_index = config.indirect_first_command_index + draw_index;
        all_indirect_commands.indirect_commands[indirect_index].instance_count = 0;

        if (config.write_debug_output) {
            atomicAdd(debug_output.culled_mesh_count, 1);
            atomicAdd(debug_output.culled_primitive_count, all_indirect_commands.indirect_commands[indirect_index].index_count / 3);
        }
    }
}

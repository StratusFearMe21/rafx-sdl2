// This code is auto-generated by the shader processor.

#[allow(unused_imports)]
use rafx::RafxResult;

#[allow(unused_imports)]
use rafx::framework::{
    DescriptorSetAllocator, DescriptorSetArc, DescriptorSetBindings, DescriptorSetInitializer,
    DescriptorSetWriter, DescriptorSetWriterContext, DynDescriptorSet, ImageViewResource,
    ResourceArc,
};

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct LightBitfieldsDataStd430 {
    pub light_count: [u32; 3072], // +0 (size: 12288)
    pub bitfields: [u32; 49152],  // +12288 (size: 196608)
} // 208896 bytes

pub type LightBitfieldsDataBuffer = LightBitfieldsDataStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct LightStd430 {
    pub position: [f32; 3], // +0 (size: 12)
    pub radius: f32,        // +12 (size: 4)
} // 16 bytes

pub type LightBuffer = LightStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct ClusterAABBStd430 {
    pub min: [f32; 3],      // +0 (size: 12)
    pub _padding0: [u8; 4], // +12 (size: 4)
    pub max: [f32; 3],      // +16 (size: 12)
    pub _padding1: [u8; 4], // +28 (size: 4)
} // 32 bytes

pub type ClusterAABBBuffer = ClusterAABBStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct LightBitfieldsStd430 {
    pub data: LightBitfieldsDataStd430, // +0 (size: 208896)
} // 208896 bytes

pub type LightBitfieldsBuffer = LightBitfieldsStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct BinLightsConfigStd430 {
    pub clusters: [ClusterAABBStd430; 3072], // +0 (size: 98304)
} // 98304 bytes

pub type BinLightsConfigBuffer = BinLightsConfigStd430;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct LightsInputListStd430 {
    pub light_count: u32,           // +0 (size: 4)
    pub _padding0: [u8; 12],        // +4 (size: 12)
    pub lights: [LightStd430; 512], // +16 (size: 8192)
} // 8208 bytes

pub type LightsInputListBuffer = LightsInputListStd430;

pub const CONFIG_DESCRIPTOR_SET_INDEX: usize = 0;
pub const CONFIG_DESCRIPTOR_BINDING_INDEX: usize = 0;
pub const LIGHTS_DESCRIPTOR_SET_INDEX: usize = 0;
pub const LIGHTS_DESCRIPTOR_BINDING_INDEX: usize = 1;
pub const BITFIELDS_DESCRIPTOR_SET_INDEX: usize = 0;
pub const BITFIELDS_DESCRIPTOR_BINDING_INDEX: usize = 2;

pub struct DescriptorSet0Args<'a> {
    pub config: &'a BinLightsConfigBuffer,
    pub lights: &'a LightsInputListBuffer,
    pub bitfields: &'a LightBitfieldsBuffer,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet0Args<'a> {
    type Output = DescriptorSet0;

    fn create_dyn_descriptor_set(
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> Self::Output {
        let mut descriptor = DescriptorSet0(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(
        descriptor_set_allocator: &mut DescriptorSetAllocator,
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> RafxResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

impl<'a> DescriptorSetWriter<'a> for DescriptorSet0Args<'a> {
    fn write_to(
        descriptor_set: &mut DescriptorSetWriterContext,
        args: Self,
    ) {
        descriptor_set.set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, args.config);
        descriptor_set.set_buffer_data(LIGHTS_DESCRIPTOR_BINDING_INDEX as u32, args.lights);
        descriptor_set.set_buffer_data(BITFIELDS_DESCRIPTOR_BINDING_INDEX as u32, args.bitfields);
    }
}

pub struct DescriptorSet0(pub DynDescriptorSet);

impl DescriptorSet0 {
    pub fn set_args_static(
        descriptor_set: &mut DynDescriptorSet,
        args: DescriptorSet0Args,
    ) {
        descriptor_set.set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, args.config);
        descriptor_set.set_buffer_data(LIGHTS_DESCRIPTOR_BINDING_INDEX as u32, args.lights);
        descriptor_set.set_buffer_data(BITFIELDS_DESCRIPTOR_BINDING_INDEX as u32, args.bitfields);
    }

    pub fn set_args(
        &mut self,
        args: DescriptorSet0Args,
    ) {
        self.set_config(args.config);
        self.set_lights(args.lights);
        self.set_bitfields(args.bitfields);
    }

    pub fn set_config(
        &mut self,
        config: &BinLightsConfigBuffer,
    ) {
        self.0
            .set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, config);
    }

    pub fn set_lights(
        &mut self,
        lights: &LightsInputListBuffer,
    ) {
        self.0
            .set_buffer_data(LIGHTS_DESCRIPTOR_BINDING_INDEX as u32, lights);
    }

    pub fn set_bitfields(
        &mut self,
        bitfields: &LightBitfieldsBuffer,
    ) {
        self.0
            .set_buffer_data(BITFIELDS_DESCRIPTOR_BINDING_INDEX as u32, bitfields);
    }

    pub fn flush(
        &mut self,
        descriptor_set_allocator: &mut DescriptorSetAllocator,
    ) -> RafxResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_struct_light_bitfields_data_std430() {
        assert_eq!(std::mem::size_of::<LightBitfieldsDataStd430>(), 208896);
        assert_eq!(std::mem::size_of::<[u32; 3072]>(), 12288);
        assert_eq!(std::mem::align_of::<[u32; 3072]>(), 4);
        assert_eq!(
            memoffset::offset_of!(LightBitfieldsDataStd430, light_count),
            0
        );
        assert_eq!(std::mem::size_of::<[u32; 49152]>(), 196608);
        assert_eq!(std::mem::align_of::<[u32; 49152]>(), 4);
        assert_eq!(
            memoffset::offset_of!(LightBitfieldsDataStd430, bitfields),
            12288
        );
    }

    #[test]
    fn test_struct_light_std430() {
        assert_eq!(std::mem::size_of::<LightStd430>(), 16);
        assert_eq!(std::mem::size_of::<[f32; 3]>(), 12);
        assert_eq!(std::mem::align_of::<[f32; 3]>(), 4);
        assert_eq!(memoffset::offset_of!(LightStd430, position), 0);
        assert_eq!(std::mem::size_of::<f32>(), 4);
        assert_eq!(std::mem::align_of::<f32>(), 4);
        assert_eq!(memoffset::offset_of!(LightStd430, radius), 12);
    }

    #[test]
    fn test_struct_cluster_aabb_std430() {
        assert_eq!(std::mem::size_of::<ClusterAABBStd430>(), 32);
        assert_eq!(std::mem::size_of::<[f32; 3]>(), 12);
        assert_eq!(std::mem::align_of::<[f32; 3]>(), 4);
        assert_eq!(memoffset::offset_of!(ClusterAABBStd430, min), 0);
        assert_eq!(std::mem::size_of::<[u8; 4]>(), 4);
        assert_eq!(std::mem::align_of::<[u8; 4]>(), 1);
        assert_eq!(memoffset::offset_of!(ClusterAABBStd430, _padding0), 12);
        assert_eq!(std::mem::size_of::<[f32; 3]>(), 12);
        assert_eq!(std::mem::align_of::<[f32; 3]>(), 4);
        assert_eq!(memoffset::offset_of!(ClusterAABBStd430, max), 16);
        assert_eq!(std::mem::size_of::<[u8; 4]>(), 4);
        assert_eq!(std::mem::align_of::<[u8; 4]>(), 1);
        assert_eq!(memoffset::offset_of!(ClusterAABBStd430, _padding1), 28);
    }

    #[test]
    fn test_struct_light_bitfields_std430() {
        assert_eq!(std::mem::size_of::<LightBitfieldsStd430>(), 208896);
        assert_eq!(std::mem::size_of::<LightBitfieldsDataStd430>(), 208896);
        assert_eq!(std::mem::align_of::<LightBitfieldsDataStd430>(), 4);
        assert_eq!(memoffset::offset_of!(LightBitfieldsStd430, data), 0);
    }

    #[test]
    fn test_struct_bin_lights_config_std430() {
        assert_eq!(std::mem::size_of::<BinLightsConfigStd430>(), 98304);
        assert_eq!(std::mem::size_of::<[ClusterAABBStd430; 3072]>(), 98304);
        assert_eq!(std::mem::align_of::<[ClusterAABBStd430; 3072]>(), 4);
        assert_eq!(memoffset::offset_of!(BinLightsConfigStd430, clusters), 0);
    }

    #[test]
    fn test_struct_lights_input_list_std430() {
        assert_eq!(std::mem::size_of::<LightsInputListStd430>(), 8208);
        assert_eq!(std::mem::size_of::<u32>(), 4);
        assert_eq!(std::mem::align_of::<u32>(), 4);
        assert_eq!(memoffset::offset_of!(LightsInputListStd430, light_count), 0);
        assert_eq!(std::mem::size_of::<[u8; 12]>(), 12);
        assert_eq!(std::mem::align_of::<[u8; 12]>(), 1);
        assert_eq!(memoffset::offset_of!(LightsInputListStd430, _padding0), 4);
        assert_eq!(std::mem::size_of::<[LightStd430; 512]>(), 8192);
        assert_eq!(std::mem::align_of::<[LightStd430; 512]>(), 4);
        assert_eq!(memoffset::offset_of!(LightsInputListStd430, lights), 16);
    }
}
